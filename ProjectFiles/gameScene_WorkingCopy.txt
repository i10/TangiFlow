//
//  GameScene.swift
//  Test1
//
//  Created by Asif Mayilli on 10/30/18.
//  Copyright Â© 2018 Test. All rights reserved.
//

import SpriteKit
import SwiftyJSON

import MultiTouchKitSwift
class GameScene: MTKScene, MTKButtonDelegate {
    var graph:Graph2?
    var traceCall:[Int:Int] = [:]
    var projectManager:ProjectFilesManager?


    override func didMove(to view: SKView) {
        self.view?.ignoresSiblingOrder = true
        graph = Graph2(scene: self)
        self.projectManager = ProjectFilesManager()
        self.projectManager?.openJson()
//        let projectJson = self.projectManager?.projectFileJson
//        var sideMenu = SideMenuTest(json: projectJson ?? [:],view:view,scene:self)
//        sideMenu.right = false
//        var sideMenuRight = SideMenuTest(json: projectJson ?? [:],view:view,scene:self)
//        sideMenuRight.position = CGPoint(x:self.size.width - 180,y:550)
//        self.addChild(sideMenu)
//        self.addChild(sideMenuRight)

        // Place all required nodes here
        // 1. Open and read restore.json
        guard let restoreJSONPath = Bundle.main.path(forResource: "restore", ofType: "json") else { return }

        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: restoreJSONPath), options: .mappedIfSafe)

            let json = try JSON(data: data)

            for j in json {
                let x = CGFloat(j.1["x"].floatValue)
                let y = CGFloat(j.1["y"].floatValue)

                let point = CGPoint(x: x, y: y)

                let node = Node(id: j.0, position: point, json: j.1, view: self.view!)
                (self.scene as! GameScene).graph?.addNode(node: node)
            }






            let node = scene?.nodes(at: CGPoint(x: 2690.0, y: 1893.0))[1] as! Node
            let nodeArc = node.arcManager!.outputArcs.first!
            let newNode = scene?.nodes(at: CGPoint(x: 3660.0, y: 211.0))[1] as! Node
            let newNodeArc = newNode.arcManager!.inputArcs.first!

            let edge = Edge.init(from: node.arcManager!.outputArcs.first!.globalPos!, to: newNode.arcManager!.inputArcs.first!.globalPos!)
            node.arcManager!.outputArcs.first!.addEdge(edge: edge)
            nodeArc.addEdge(edge: edge)
            newNodeArc.addEdge(edge: edge)

            let trace = TraceToActivity.init(from: node.arcManager!.outputArcs.first!, to: newNode.arcManager!.inputArcs.first!)
            trace.edge = edge
            if let activity = TraceToActivity.getActivity(by: trace.id!) {
                activity.edge?.redrawEdge(on: scene!, from: node.arcManager!.outputArcs.first!.globalPos!, to: newNode.arcManager!.inputArcs.first!.globalPos!)
            }

//            nodeArc.redrawArc(with: 1)
//            newNodeArc.redrawArc(with: 1)


            // to
            if nodeArc.parentNode != newNodeArc.parentNode && nodeArc.isInput != newNodeArc.isInput {
                newNodeArc.parentNode?.inArgs[newNodeArc.name!] = nodeArc.parentNode?.id
                trace.to = newNodeArc
                trace.from = nodeArc
                trace.from?.addEdge(edge: trace.edge!)
                trace.to?.addEdge(edge: trace.edge!)
                trace.edge?.from = nodeArc
                trace.edge?.to = newNodeArc
                trace.edge?.redrawEdge(from: nodeArc.globalPos!, to: newNodeArc.globalPos!)
                trace.currentTrace = nil
                newNodeArc.changeArcColor()
                newNodeArc.redrawArc(with: 1)
            }


            // from
            nodeArc.changeArcColor()
            nodeArc.isInput = false
            self.setActivity(activity: trace, trace: MTKTrace.init(), to: newNodeArc, from: nodeArc,arc: nodeArc)
            EdgeManager().addEdge(edge: trace.edge!)
            nodeArc.redrawArc(with: 1)
            nodeArc.addEdge(edge: trace.edge!)

            nodeArc.changeArcColor()

        } catch {
            print("Error: ", error.localizedDescription)
        }














    }











    func setActivity(activity:TraceToActivity,trace:MTKTrace,to:Arc?,from:Arc?,arc:Arc){
        activity.currentTrace = trace.uuid
        activity.edge = Edge(from: CGPoint.zero, to: CGPoint.zero)
        activity.edge?.zPosition = -2
        activity.edge?.to = to
        activity.edge?.from = from
        activity.fulcrum = arc
    }










    override func setupScene() {
        FileHandler.shared.cleanContent(of:FileHandler.shared.imagesFolderPath)
        FileHandler.shared.cleanContent(of:FileHandler.shared.resultFolderPath)
        graph = Graph2(scene: self)
        MTKHub.sharedHub.traceDelegate = self
    }

    func preProcessTraceSet(traceSet: Set<MTKTrace>, node: SKNode, timestamp: TimeInterval) -> Set<MTKTrace> {
        for trace in traceSet{
            if trace.state == MTKUtils.MTKTraceState.beginningTrace{
                self.graph?.touchDown(trace: trace)
            }else if trace.state == MTKUtils.MTKTraceState.movingTrace{
                self.graph?.touchMove(trace: trace)
            }else{
                self.graph?.touchUp(trace: trace)
                print("Line: #74, File: GameScene ::: ", trace.position)

                let allNodes = NodeManager.nodeList
                var textFields:[CustomTextFields] = []
                for node in allNodes{
                    if let controlElements = node.controlElements {
                        textFields += textFields + controlElements.textFields
                    }

                }
                for textField in textFields{
                    if textField.frame.origin.x < trace.position!.x && trace.position!.x < textField.frame.origin.x + 200 &&
                        textField.frame.origin.y < trace.position!.y && trace.position!.y < textField.frame.origin.y + 80{

                       // textField.isEnabled = true
                        textField.isEditable = true
                        //textField.becomeFirstResponder()
                        textField.window?.makeFirstResponder(textField)
                        //textField.stringValue = ""
                       // print(textField.stringValue)

                            textField.parent?.keyboard.removeFromParent()
                            textField.parent?.addChild(textField.parent!.keyboard)
                            textField.parent!.keyboard.drawKeys()
                            textField.parent?.keyboard.position = CGPoint(x: 600, y: 200)

                        textField.parent!.keyboard.activeTextInput = textField
                    }
                }
                //print(tf)
            }
                self.nodes(at: trace.position!)

        }

        return traceSet
    }



    override func update(_ currentTime: TimeInterval) {
        super.update(currentTime)

    }

//    @objc func run(button:MTKButton,id:String){
//        let scr = ScriptRunner()
//        scr.script(id:id)
//        let resultMaker = ResultVisualization()
//        resultMaker.getResults()
//    }

}
